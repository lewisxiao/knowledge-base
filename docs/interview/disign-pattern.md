# 1. 设计模式分类
* 创建型模式
* 结构型模式
* 行为型模式

## 2. 创建型模式
### 2.1 单例模式
单例模式分类：
* 饿汉式单例
* 懒汉式单例：多线程时存在线程安全问题
* synchronized单例
* 双重检查锁单例

扩展：为什么会发生指令重排？如何避免指令重排？
> 指令重排是指在编译器优化或处理器乱序执行时，会改变代码中指令的执行顺序，以提高性能。在多线程编程中，指令重排可能会导致程序出现意外的行为，因为代码的执行顺序与预期不符。为了避免这种情况，可以使用同步机制，如volatile关键字或synchronized关键字来保证指令不会被重排。这样可以确保程序的正确性和可靠性。


### 2.2 工厂模式
工厂模式分类：
* 简单工厂：工厂类中负责对象的创建
* 工厂方法：对简单工厂的改进，区分了抽象工厂类、子工厂类，在子工厂类中创建对象
* 抽象工厂：对工厂方法的扩展，能创建多个不通产品线的产品


### 2.3 建造者模式
类的构造过于复杂，而且变化多样，不适宜放在构造函数中处理时，可以使用建造者模式


### 2.4 原型模式
简单地理解，就是一种克隆对象的方法。

浅拷贝：当拷贝的对象只包含简单类型（int和float）或不可变对象时，直接将这些字段克隆到新独享中

深拷贝：如果克隆的对象还包含了其它对象的引用，这就是深拷贝


### 2.5 对象池模式
这是常用的池化技术，比如数据库连接池、线程池，当要创建的是外部对象，而且创建这个对象的成本很高昂时，解决的方式就是重用、共享这些创建成本高昂的对象。


## 3. 结构型模式


### 3.1 适配器模式


### 3.2 代理模式


### 3.3 装饰器模式


### 3.4 桥接模式


### 3.5 组合模式


### 3.6 外观模式


### 3.7 享元模式


## 4. 行为型模式
创建型模式有助于对象的创建和管理，对象创建出来后，需要进行管理，而行为型模式就是为管理对象提供的一种简便的方法。


### 4.1 责任链模式
一句话理解：如果需要则处理请求，否则将请求传递给下一个处理器。

javax.servlet.Filter 就是这个的实现。

### 4.2 命令模式


### 4.3 解释器模式


### 4.4 迭代器模式
迭代器模式用于遍历一组对象，而不用暴露对象的内部实现方法

该模式广泛应用于 JDK 中，比如：数组、列表、集合

### 4.5 观察者模式


### 4.6 中介模式


### 4.7 备忘录模式


### 4.8 状态模式


### 4.9 策略模式


### 4.10 模板方法模式


### 4.11 空对象模式


### 4.12 访问者模式


## 5. UML中的6种关系
* 关联关系
* 依赖关系
* 聚合关系
* 组合关系
* 泛化关系
* 接口实现关系


## 6. 6种设计原则
* 单一职责
* 开闭原则
* 接口隔离原则
* 里氏替换原则
* 依赖倒置原则
* 迪米特原则


## 7. 设计模式存在的价值
面对日益变化的需求，设计模式作为前人总结的经验，能在需求变化时，后人可以方便的进行扩展。而无需了解、改动之前的实现。

解耦的目标就是扩展。