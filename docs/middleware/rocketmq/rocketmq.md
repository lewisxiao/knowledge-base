# RocketMQ
引用 [RocketMQ 官网](https://rocketmq.apache.org/docs/)的一段话:
> 根据我们的研究，随着队列和虚拟主题使用的增加，ActiveMQ IO模块达到了一个瓶颈。我们尽力通过节流、断路器或降级来解决这个问题，但效果并不理想。于是我们尝试了流行的消息传递解决方案
> Kafka。不幸的是，Kafka不能满足我们的要求，其尤其表现在低延迟和高可靠性方面，详见这里。在这种情况下，我们决定发明一个新的消息传递引擎来处理更广泛的消息用例，
> 覆盖从传统的pub/sub场景到高容量的实时零误差的交易系统。

> Apache RocketMQ 自诞生以来，因其架构简单、业务功能丰富、具备极强可扩展性等特点被众多企业开发者以及云厂商广泛采用。历经十余年的大规模场景打磨，RocketMQ 已经成为业内共识的金融级可
> 靠业务消息首选方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景。

## 四大组件
### Producer
消息的生产者，负责生产消息，然后根据 RocketMQ 的负载均衡模块选择 broker 进行消息投递。

消息生产者都是以生产者组的形式存在的。如果创建生产者时未指定组，则会被默认分配到一个默认的组`DEFAULT_PRODUCER`。生产者组是同一个生产者的集合，可以往同一个 Topic 发送的消息，
一个生产者组可以同时发送多条消息。

生产者的概念包括**消息 - Message**、**Tag**、**队列**。

#### 消息

#### Tag
Topic 和 Tag 都是业务上用来对消息进行归类的标识，可以将 Topic 看作一级分类，而 Tag 可以看作二级分类。使用 Tag 还可以对 Topic 中的消息进行过滤。

```tip
Topic：消息主题，通过 Topic 对不同的业务消息进行分类。
Tag：消息标签，用来进一步区分某个 Topic 下的消息分类，消息从生产者发出即带上的属性。
```

#### 队列
消息按 Topic 进行以队列的形式分区存放，一个 Topic 可以有多个队列，并且分布在不同的 broker 上。正常情况下哎，一条消息只会存在一个 Topic 的一个队列中，消息在队列中按照先进先出的方式存储。

#### 实践：发送消息
生产者在发送消息时，采用轮询的方式选取队列，以保证每个队列接收的消息量相等。

创建一个生产者，一般分为5步：
  1. 创建 DefaultMQProducer 对象，设定好分组名称
  2. 参数配置，设定好 name server 地址
  3. 启动 producer
  4. 构建好消息，指定 Topic、Tag、消息体，最后发送
  5. 消息发送完成后，关闭 producer

```java
/**
 * 例子：同步发送消息
 */
public class SyncProducer {
    public static void main(String[] args) throws Exception {
        send();
    }

    public static void send() throws Exception {
        // 初始化一个producer并设置Producer group name
        DefaultMQProducer producer = new DefaultMQProducer("sync_group");

        // 设置NameServer地址
        producer.setNamesrvAddr("localhost:9876");

        // 启动producer
        producer.start();

        try {
            for (int i = 0; i < 100; i++) {
                Message message = new Message("syncTopic", "smsTagA", ("你好 RocketMQ" + i).getBytes(StandardCharsets.UTF_8));
                message.putUserProperty("subTag1", "subTag1");
                SendResult sendResult = producer.send(message);
                System.out.printf("%s%n", sendResult);
            }
        } finally {
            // 使用完毕后，关闭producer
            producer.shutdown();
        }
    }
}
```

> 注意：
> 同步消息内部会有一个重试机制，会造成消息重复发送。由于RocketMQ无法消除重复消息，所以需要开发者需要在消费消息的逻辑中自行处理这类情况，可以采用幂等、维护消息消费记录的方式处理。

#### 四种消息类型、三种方式
> 注意：不同的消息类型，不要共用相同的 topic。

生产者在发送消息时，支持四种消息类型，以支持不同的应用场景。消息发送有三种方式：**同步发送、异步发送、单向发送**

**同步发送**  
同步发送是最常用的方式，是指消息发送方发出一条消息后，会在收到服务端同步响应之后才发下一条消息的通讯方式，同步发送作为一种可靠的发送，被广泛应用于各种场景，如重要的通知消息、短消息通知等。

三种方式下，仅同步发送才有重试机制，重试有可能会造成消息重复发送。由于RocketMQ无法消除重复消息，所以需要开发者需要在消费消息的逻辑中自行处理这类情况，可以采用幂等、维护消息消费记录的方式处理。

**异步发送**  
异步发送是指发送方发出一条消息后，不等服务端返回响应，接着发送下一条消息的通讯方式。异步发送一般用于链路耗时较长，对响应时间较为敏感的业务场景。例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。

**单向传输**  
发送方只负责发送消息，不等待服务端返回响应且没有回调函数触发，即只发送请求不等待应答。 此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。

##### 普通消息
平平无奇的一种模式，相比其他几种类型，可以说普通消息没有任何特点，消息送达后就结束了，如果对消息没有顺序、延迟、吞吐量、事务的要求，就可采用该模式。

#### 顺序消息
对消息的发送、消费顺序有严格要求的消息。

RocketMQ支持分区顺序消息，对于一个 Topic 下的消息，消息严格按照先进先出的原则进行发送和消费。**必须同时满足发送顺序性、消费顺序性，才能算是顺序消息。**

例如创建订单的场景，需要保证同一个订单的生成、付款和发货，这三个操作被顺序执行。如果是普通消息，订单A的消息可能会被轮询发送到不同的队列中，不同队列的消息将无法保持顺序，而顺序消息发送时将ShardingKey相同（同一订单号）的消息序路由到一个逻辑队列中。

**生产顺序性**  
  * 单一生产者：消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的分区键，不同生产者之间产生的消息也无法判定其先后顺序。需要按照某一个标准对消息进行分区（比如图中的ShardingKey），同一个ShardingKey的消息会被分配到同一个队列中，并按照顺序被消费。

  * 串行发送：生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。

**消费顺序性**  
RocketMQ 已经提供顺序消费的实现，消费者在注册消费回调接口时传入MessageListenerOrderly接口的实现即可。**但是需要注意，如果顺序消费时，某一条消息阻塞了，会导致后面的消息都无法处理，必须等待阻塞的消息处理完。**

#### 延迟消息
延迟消息指的是延迟消费，生产者在发送消息前设置好延迟的等级，然后把消息发送到 broker，但是不期望马上消费该条消息，而是期望根据延迟等级延迟一段时间再进行消费。例如生成一个订单后，用户30分钟内未进行支付，则需要取消订单、并恢复库存。

RocketMQ 支持18个延迟等级，范围从 1s ~ 2h 不等。

#### 批量消息
对吞吐率有要求的时候，在发送消息时将多个消息打包后进行发送，可以增加吞吐率，减少API和网络调用次数。

#### 事务消息
TBD...

#### Producer Group
生产者组是同一类生产者的组合，不同的生产者也是可以给同一个 Topic 推送消息的。

#### 主题(Topic
Topic 是一个逻辑上的概念，Topic 由多个 queue 组成，而 queue 会分布在不同的 broker 上。

Topic创建的时候可以用集群模式去创建（这样集群里面每个broker的queue的数量相同），也可以用单个broker模式去创建（这样每个broker的queue数量可以不一致）。

 每个broker上面的 queue 保存了该 topic 的一部分消息，而不是全量消息。

### 消费者 Consumer

### 名字服务器 NameServer
集群的协调者，Topic 的路由注册中心，支持 Topic、Broker 的动态注册与发现。

NameServer 是无状态的，每个实例保存着一份完整的路由信息，且各个实例相互之间不会通信，可以方便地作集群部署。

由于是无状态，为了保存和维护集群的元数据，不需要分布式锁了。再加上读取操作多，更改操作少特点，选择读写锁能大大提高效率。

所有的元数据保存在 **RouteInfoManager** 类中，打开就能看见读写锁的大量使用。

NameServer 很轻量，实现简单，代码量极少。底层通信依旧是采用了 Netty。
![Namesrv](./image/nameserver.jpg)

功能包括两个部分：
  * broker 定期上报自己的状态信息到 name server
  * 客户端（producer、consumer、命令行工具）通过 name server 获取最新的配置信息
### 代理服务器 Broker


## 常见问题
### 集群模式下，RocketMQ在推送消息给消费者时，是如何做负载均衡的？

### 什么是顺序消费？在顺序消费模式下，RocketMQ是如何保证顺序消费的？

### 消息堆积（积压）应该如何解决？

### 什么是 Rebalance 机制

### 如何做集群部署

## 项目实践
在处理企微回调时，将接收到的消息转发到消息队列，防止瞬间的流量过大而引发系统崩溃


## 学习资料
1. [RocketMQ负载均衡](https://blog.csdn.net/Weixiaohuai/article/details/123898841)